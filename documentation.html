---
layout: documentation
title: TSFramework - Documentation
---

<h1 id="what-is-typemvc">What is TSFramework?</h1>

<p>TSFramework is web application framework that implements the model-view-controller (MVC) pattern which runs via Node.js and TypeScript programming language. It is designed to assemble other MVC frameworks like Ruby on Rails, Zend, ASP.NET MVC etc.. TSFramework combines the performance of NodeJS platform together with the power of TypeScript to give you a web framework that is fast and scalable.</p>

<p>TSFramework does a few things different from other web frameworks:</p>

<h2 id="typescript">TypeScript</h2>

<p>TypeScript is an amazing language that does a wonderful job of extending JavaScript. It is a strict superset of JavaScript that adds static typing and and class-based OOP to the language. Because it is a superset, your existing JavaScript files are already TypeScript which makes the transition to the language extremely easy. You can learn more about it <a href="http://www.typescriptlang.org">here</a>.</p>

<h2 id="nodejs">Node.js</h2>

<p>Node.js allows JavaScript to run on server-side. It is designed to maximize performance using non-blocking I/O and asynchronous events.</p>

<h2 id="express">Express</h2>

<p>TSFramework controllers are really just Express middlewares. TSFramework uses the Express v4 and supports the existing ecosystem of Express middleware.</p>

<h2 id="rest-routing">REST Routing</h2>

<p>TypeScript generates API for your models so you don’t have to write any backend code to handle CRUD. It also generates default REST for your models.</p>

<h1 id="controllers">Controllers</h1>

<p>Controllers are defined in the <code>/app/controllers/</code> folder. Creating a new controller is easy, all you need to do is extend the TF.Controller. The following controller defines a single action named <code>index</code> that returns ‘Hello world’:</p>

<pre><code>class HomeController extends TF.Controller {
    index() {
        this.content('Hello world!');
    }
}</code></pre>

<h2 id="action-parameters">Action Parameters</h2>

<p>You can also pass parameters into action and TSFramework will automatically convert data into correct type for you:</p>

<pre><code>class HomeController extends TF.Controller {
    hello(name: string) {
        this.content('Hello: ' + name);
    }
}</code></pre>

<p>If your visit the action with <code>/hello?name=John</code> for example, the action will render ‘Hello John’. The parameter doesn’t have to be a query string, it could be any of these in this order:</p>

<ul>
    <li>Routing parameters (see <a href="#routing">Routing</a> for learn more about routing parameters)</li>
    <li>Request body</li>
    <li>Query string</li>
</ul>

<h2 id="reply-interface">Reply Interface</h2>

<p>Every controller in TSFramework inherits the Reply interface which is implemented in the base controller. This interface is mainly used for sending data back to user.</p>

<h3 id="send-a-text-response">Send a text response</h3>

<pre><code>this.content(text: string);
this.content(text: string, contentType: string);</code></pre>

<h3 id="send-a-json-response">Send a JSON response</h3>

<pre><code>this.json(data: {});</code></pre>

<h3 id="render-a-view">Render a view</h3>

<pre><code>this.view(template: string);
this.view(template: string, options: {});</code></pre>

<h3 id="send-a-response-from-file">Send a response from file</h3>

<pre><code>this.file(path: string);</code></pre>

<h3 id="download-a-file">Download a file</h3>

<pre><code>this.download(path: string);
this.download(path: string, filename: string);</code></pre>

<h3 id="redirect-to-a-url">Redirect to a url</h3>

<p>Redirect to the given url with optional status code defaulting to 302 “Found”:</p>

<pre><code>this.redirect(url: string);
this.redirect(url: string, status: number);</code></pre>

<h2 id="request-object">Request Object</h2>

<p>Each controller that inherits the TF.Controller will have access to the Request object via <code>this.request</code>. You can use the request object to query information about the user request.</p>

<ul>
    <li><code>request.param()</code>: get query string, routing params or POST data…</li>
    <li><code>request.query</code>: returns query string data.</li>
    <li><code>request.cookies</code>: returns cookie data.</li>
    <li><code>request.get()</code>: get the case-insensitive request header field.</li>
    <li><code>request.host</code>: returns the hostname from the “Host” header field.</li>
</ul>

<p>The TSFramework request object extends Express Request object. You can check out the <a href="http://expressjs.com/4x/api.html">Express guide</a> for more information.</p>

<h2 id="response-object">Response Object</h2>

<p>Each controller that inherits the TF.Controller will have access to the Response object via <code>this.response</code>. You can use the response object to send data back to user.</p>

<h3 id="get-or-set-response-status">Get or set response status:</h3>

<pre><code>this.response.setStatus(404);
this.response.getStatus();</code></pre>

<h3 id="get-or-set-response-header">Get or set response header:</h3>

<pre><code>this.response.setHeader('Content-Type', 'text/plain');
this.response.getHeader('Content-Type');</code></pre>

<h3 id="set-or-remove-a-cookie">Set or remove a cookie</h3>

<pre><code>this.response.setCookie('name', 'john', { domain: '.example.com', path: '/admin', secure: true });
this.response.removeCookie('name');
this.response.removeCookie('name', '/admin');</code></pre>

<h3 id="set-response-content-type">Set response content type:</h3>

<pre><code>this.response.setContentType('text/plain');</code></pre>

<h3 id="set-response-link-header-field">Set response Link header field</h3>

<p>Join the given links to populate the “Link” response header field:</p>

<pre><code>this.response.setLinks({
    next: 'http://api.example.com/users?page=2',
    last: 'http://api.example.com/users?page=5'
});</code></pre>

<h3 id="get-or-set-local-data">Get or set local data</h3>

<p>Response local data are scoped to the request and will be exposed to the views:</p>

<pre><code>this.response.setLocal('name': 'John');</code></pre>

<h2 id="action-filters">Action Filters</h2>

<p>Action filters are method that run before, after or around a controller action.</p>

<p>Filters may halt the request cycle. A common filter is one which requires that a user is logged in for an action to be run. You can add a filter to a controller this way by passing a function that accepts TF.ActionFilterContext as a parameter:</p>

<pre><code>class UserController extends TF.Controller {
    static configure() {
        this.addBeforeFilter(this.authenticate);
    }

    static authenticate(context: TF.ActionFilterContext) {
        var isAuthenticated = ...;
        if (!isAuthenticated)
            context.reply.redirect('/login');
        else
            context.next();
    }
}</code></pre>

<p>Alternatively you can also create a class that extends TF.ActionFilter. The advantage of doing this is that you can have both <code>before</code> and <code>after</code> filters in the same class which will create a <code>around</code> filter:</p>

<pre><code>class SpeedLogger extends TF.ActionFilter {
    private start: number;

    before(context: TF.IActionFilterContext) {
        this.start = new Date().getTime();
        context.next();
    }

    after(context: TF.IActionFilterContext) {
        var elapse = new Date().getTime() - this.start;
        ...
        context.next();
    }
}

class UserController extends TF.Controller {
    static configure() {
        this.addFilter(SpeedLogger);
    }
}</code></pre>

<p>Action filters by default will be applied to all actions, but your can also exclude some actions:</p>

<pre><code>this.addFilter(...).except('login');</code></pre>

<p>You can also choose to apply filter to a certain actions and exclude the rest:</p>

<pre><code>this.addFilter(...).only('index', 'login');</code></pre>

<h1 id="models">Models</h1>

<p>TSFramework uses Waterline ORM (created by Sails.js). Waterline allows developers to interact with models the same way regardless of data source they’re using.</p>

<p>Models are defined in the <code>/app/models/</code> folder .To create a model, just extends TF.Model. The following User model defines 3 attributes <code>name</code>, <code>email</code> and  <code>age</code>:</p>

<pre><code>class User extends TF.Model {
    name: string;
    email: string;
    age: number;
}</code></pre>

<p>Model attributes can also be validated like so:</p>

<pre><code>class User extends TF.Model {
    name: string;
    email: string;
    age: number;

    static configure() {
        this.validate('age', { required: false, min: 18 });
    }
}</code></pre>

<p>Available validations:</p>

<p><code>empty</code>, <code>required</code>, <code>notEmpty</code>, <code>undefined</code>, <code>string</code>, <code>alpha</code>, <code>numeric</code>, <code>alphanumeric</code>, <code>email</code>, <code>url</code>, <code>urlish</code>, <code>ip</code>, <code>ipv4</code>, <code>ipv6</code>, <code>creditcard</code>, <code>uuid</code>, <code>uuidv3</code>, <code>uuidv4</code>, <code>int</code>, <code>integer</code>, <code>number</code>, <code>finite</code>, <code>decimal</code>, <code>float</code>, <code>falsey</code>, <code>truthy</code>, <code>null</code>, <code>notNull</code>, <code>boolean</code>, <code>array</code>, <code>date</code>, <code>hexadecimal</code>, <code>hexColor</code>, <code>lowercase</code>, <code>uppercase</code>, <code>after</code>, <code>before</code>, <code>is</code>, <code>regex</code>, <code>not</code>, <code>notRegex</code>, <code>equals</code>, <code>contains</code>, <code>notContains</code>, <code>len</code>, <code>in</code>, <code>notIn</code>, <code>max</code>, <code>min</code>, <code>minLength</code>, <code>maxLength</code>,</p>

<p>Check out the <a href="https://github.com/balderdashy/waterline">Waterline documentation</a> for more information.</p>

<h2 id="save-a-model">Save a Model</h2>

<pre><code>var user = new User('John', 'john@test.com');
user.save((err) =&gt; {
    // callback
});</code></pre>

<h2 id="update-a-model">Update a Model</h2>

<p>Find user with id <code>1</code> and update name to ‘John Doe’:</p>

<pre><code>User.get(1).done((err, user: User) =&gt; {
    user.name = 'John Doe';
    user.save((err) =&gt; {
        // callback
    });
});</code></pre>

<h2 id="destroy-a-model">Destroy a Model</h2>

<p>Find user with id <code>1</code> and delete model:</p>

<pre><code>User.get(1).done((err, user: User) =&gt; {
    user.name = 'John Doe';
    user.destroy((err) =&gt; {
        // callback
    });
});</code></pre>

<h2 id="query-models">Query Models</h2>

<p>Lookup a model by id:</p>

<pre><code>User.get(1).done((err, user: User) =&gt; { /* callback */ });</code></pre>

<p>Lookup a model by other attributes:</p>

<pre><code>User.first({ name: 'John' }).done((err, user: User) =&gt; { /* callback */ });</code></pre>

<p>Get a list of users with name ‘John’:</p>

<pre><code>User.find()
    .where({ name: 'John' })
    .done((err, users: User[]) =&gt; { /* callback */ });</code></pre>

<p>Get 5 users with name ‘John’ and ignore the first 10:</p>

<pre><code>User.find()
    .where({ name: 'John' })
    .skip(10)
    .limit(5)
    .done((err, users: User[]) =&gt; { /* callback */ });</code></pre>


<h1 id="view-engine">View Engine</h1>

<p>TSFramework uses <a href="http://embeddedjs.com">EJS</a> for its view engine. To render a view you would use <code>response.render</code> in your controller action:</p>

<pre><code>index(name: string) {
    this.response.render('index', { user: name });
}</code></pre>

<p>Render view with a layout:</p>

<pre><code>this.response.render('index', { layout: 'my_layout' });</code></pre>

<h2 id="structuring-layouts">Structuring Layouts</h2>

<p>When TSFramework renders a view as a response, it does so by combining the view with the current layout. Within a layout, you have access to these tools for combining different bits of output to form the overall response:</p>

<ul>
    <li>Body</li>
    <li>Section &amp; contentFor</li>
    <li>Partials</li>
</ul>

<h3 id="body">Body</h3>

<p>A layout should always contains a <code>&lt;%- body %&gt;</code> which is where your view template will be rendered:</p>

<p>A view:</p>

<pre><code>&lt;h1&gt;Hello world!&lt;/h1&gt;</code></pre>

<p>With a layout:</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%- body %&gt;
    &lt;/body&gt;
&lt;html&gt;</code></pre>

<h3 id="sections--contentfor">Sections &amp; contentFor</h3>

<p>You can declare multiple sections in a layout and implement them in a view.</p>

<p>A view:</p>

<pre><code>&lt;h1&gt;Hello world!&lt;/h1&gt;

&lt;%- contentFor('header') %&gt;
&lt;style&gt;...&lt;/style&gt;

&lt;%- contentFor('footer') %&gt;
&lt;script&gt;...&lt;/script&gt;</code></pre>

<p>With a layout:</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;%- header %&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%- body %&gt;

        &lt;footer&gt;
            &lt;%- footer %&gt;
        &lt;/footer&gt;
    &lt;/body&gt;
&lt;html&gt;</code></pre>

<h4 id="optional-section">Optional section:</h4>

<p>By default a section declared in a layout must be implemented in a view, an error will be throw otherwise. You can make a section optional using <code>defineContent</code>:</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;%- defineContent('header') %&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%- body %&gt;
    &lt;/body&gt;
&lt;html&gt;</code></pre>

<h3 id="partials">Partials</h3>

<p>Partial templates - or just “partials” - are another way of for breaking the rendering process into more manageable chunks. With a partial you can put a certain piece of popular code to its own file. Partials are being called using <code>include</code> and can be inserted into both layouts and views:</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;%- include my_partial.ejs %&gt;
        &lt;%- body %&gt;
    &lt;/body&gt;
&lt;html&gt;</code></pre>

<p>For more information EJS template syntax, please see <a href="http://embeddedjs.com/getting_started.html">EJS documentation</a>.</p>

<h1 id="routing">Routing</h1>

<p>TSFramework routes are normally declared in Global.ts via <code>app.router</code>. When you generate a new app, these routes are generated for you by default:</p>

<pre><code>// default routes
    app.router.map('/', { controller: 'Home', action: 'index' });
    app.router.map('/:controller/:action?/:id?', { action: 'index' });
</code></pre>

<p>The first route maps the application root path to action <code>index</code> in <code>Home</code> controller.</p>

<p>The second route is the catch all for all controller actions. For example, if you have a UserController with action <code>login</code>, you can access the action using this url:</p>

<pre><code>http://localhost:3000/User/login</code></pre>

<p>The <code>index</code> action was set as default, so you can access it by omitting the action param:</p>

<pre><code>http://localhost:3000/User</code></pre>

<h2 id="crud-and-actions">CRUD and Actions</h2>

<p>In TSFramework, a resourceful route provides a mapping between HTTP verbs and URLs to controller actions. By convention, each action also maps to particular CRUD operations in a database. To generate default CRUD actions for your controller you just need to assign a Model to your controller:</p>

<pre><code>UserController.model = User;</code></pre>

<p>These actions will be generated for your model controller:</p>

<ul>
    <li><code>find</code>: return a list of items</li>
    <li><code>find(id)</code>: return the item with specified id</li>
    <li><code>create</code>: create a item</li>
    <li><code>update(id)</code>: update an existing item</li>
    <li><code>destroy(id)</code>: delete an existing item</li>
</ul>

<h2 id="resourceful-routing">Resourceful Routing</h2>

<p>By default, TSFramework also generates a REST routes for any controller with a model attached:</p>

<pre><code>// REST routes
    app.router.get('/:controller/:id?', { action: 'find' });
    app.router.post('/:controller', { action: 'create' });
    app.router.put('/:controller/:id', { action: 'update' });
    app.router.delete('/:controller/:id', { action: 'destroy' });
</code></pre>

<h1 id="configuration">Configuration</h1>

<p>TSFramework configuration settings are defined in <code>app.json</code> in JSON format:</p>

<pre><code>{
    "port": 3000,
    "logging": {
        "format": "dev"
    }
}
</code></pre>

<p>To retrieve specified setting declared in <code>app.json</code>, use <code>app.config.get</code>. The following code would retrieve the value of the default adapter module name shown earlier in app.json:</p>

<pre><code>app.config.get('adapters.default.module');</code></pre>

<h2 id="general-configuration">General Configuration</h2>

<ul>
    <li><code>env</code> (string): returns Node.js environment variable which defaults to <code>development</code>.</li>
    <li><code>port</code> (number): the port number your app will be listening on, defaults to <code>3000</code>.</li>
    <li><code>assetPath</code> (string): the path to the public folder, defaults to <code>public</code>.</li>
    <li><code>view.path</code> (string): the path to the views folder, defaults to <code>app/views</code>.</li>
    <li><code>view.engine</code> (string): the view engine, defaults to <code>ejs</code>.</li>
    <li><code>view.layout</code> (string, boolean): the default layout to be used for templates, defaults to <code>false</code>.</li>
    <li><code>logging.format</code> (string): whether app should log all request to console. Available options:
        <ul>
            <li><code>default</code>: standard output.</li>
            <li><code>short</code>: shorter than default, also including response time.</li>
            <li><code>tiny</code>: the minimal.</li>
            <li><code>dev</code>: concise output colored by response status for development use.</li>
        </ul>
    </li>
</ul>

<h2 id="adapter-configuration">Adapter Configuration</h2>

<p>You can declare as many adapters as you need in <code>adapters</code> setting. The following config declares a <code>default</code> adapter using module <code>sails-disk</code>:</p>

<pre><code>{
    "adapters": {
        "default": {
            "module": "sails-disk",
            "schema": true,
            "filePath": ".build/database.json"
        }
    }
}</code></pre>